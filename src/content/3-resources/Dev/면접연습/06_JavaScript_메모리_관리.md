# JavaScript의 메모리 관리와 가비지 컬렉션

## 질문
JavaScript의 메모리 관리와 가비지 컬렉션에 대해 설명해주세요.

## 답변
JavaScript는 자동 메모리 관리를 제공하는 가비지 컬렉션 언어입니다. 주로 참조 카운팅과 마크-앤-스윕 알고리즘을 사용합니다. 참조 카운팅은 객체에 대한 참조 수를 세고, 마크-앤-스윕은 루트부터 도달 가능한 객체를 마킹하고 도달할 수 없는 객체를 메모리에서 해제합니다. 모던 브라우저는 주로 마크-앤-스윕과 그 변형을 사용합니다.

### 참고 자료
- [MDN: 메모리 관리](https://developer.mozilla.org/ko/docs/Web/JavaScript/Memory_Management)
- [JavaScript.info: 가비지 컬렉션](https://ko.javascript.info/garbage-collection)

### 가비지 컬렉션 동작 방식 도식화
```
┌──────────────────────────────────────┐
│       JavaScript 메모리 관리          │
└────────────────────┬─────────────────┘
                     │
      ┌──────────────┴─────────────┐
      │                            │
      ▼                            ▼
┌─────────────────┐      ┌──────────────────┐
│  참조 카운팅     │      │  마크-앤-스윕    │
└────────┬────────┘      └─────────┬────────┘
         │                         │
         ▼                         ▼
┌─────────────────┐      ┌──────────────────┐
│ 각 객체에 대한  │      │ 1. 루트에서 시작  │
│ 참조 수 카운트  │      │ 2. 도달 가능한    │
│                 │      │    객체 마킹     │
│ 참조 수가 0이면 │      │ 3. 마킹되지 않은  │
│ 메모리 해제     │      │    객체 메모리 해제│
└─────────────────┘      └──────────────────┘
```

## 꼬리 질문 1
클로저와 메모리 누수의 관계는 무엇인가요?

### 답변
클로저는 자신이 생성된 렉시컬 환경을 기억하는 함수로, 외부 변수에 접근할 수 있습니다. 클로저가 생성되면 참조하는 외부 변수는 가비지 컬렉션 대상에서 제외됩니다. 이때 클로저가 불필요하게 큰 데이터를 참조하거나, 이벤트 리스너와 같이 장시간 유지되는 클로저를 제대로 해제하지 않으면 메모리 누수가 발생할 수 있습니다.

### 참고 자료
- [MDN: 클로저](https://developer.mozilla.org/ko/docs/Web/JavaScript/Closures)
- [JavaScript 메모리 누수와 해결 방법](https://auth0.com/blog/four-types-of-leaks-in-your-javascript-code-and-how-to-get-rid-of-them/)

### 클로저와 메모리 누수 도식화
```
┌──────────────────────────────────────┐
│   클로저와 메모리 관리의 관계         │
└────────────────────┬─────────────────┘
                     │
                     ▼
┌───────────────────────────────────────────┐
│ 함수 실행 컨텍스트                         │
│ ┌───────────────────────────────────┐     │
│ │ 외부 함수                          │     │
│ │ ┌───────────────────────────────┐ │     │
│ │ │ 지역 변수                      │ │     │
│ │ │ ┌─────────────────────────┐   │ │     │
│ │ │ │ 내부 함수 (클로저)       │   │ │     │
│ │ │ └─────────────────────────┘   │ │     │
│ │ └───────────────────────────────┘ │     │
│ └───────────────────────────────────┘     │
└───────────────────────────────────────────┘
                     │
                     ▼
┌───────────────────────────────────────────┐
│ 외부 함수 실행 완료                        │
│ ┌───────────────────────────────────┐     │
│ │ 외부 함수의 렉시컬 환경            │     │
│ │ (참조 유지)                       │     │
│ │ ┌───────────────────────────────┐ │     │
│ │ │ 지역 변수                      │ │     │
│ │ └───────────────────────────────┘ │     │
│ └───────┬───────────────────────────┘     │
│         │                                 │
│         ▼                                 │
│ ┌─────────────────────────┐               │
│ │ 내부 함수 (클로저)       │               │
│ │ 외부 렉시컬 환경 참조    │               │
│ └─────────────────────────┘               │
└───────────────────────────────────────────┘
```

## 꼬리 질문 2
JavaScript에서 흔히 발생하는 메모리 누수의 원인과 해결 방법은 무엇인가요?

### 답변
주요 원인으로는 1) 전역 변수의 과도한 사용, 2) 제거되지 않은 이벤트 리스너, 3) 클로저의 부적절한 사용, 4) setInterval/setTimeout의 참조 해제 실패, 5) DOM 요소에 대한 직접 참조가 있습니다. 해결 방법으로는 변수 스코프 제한, 이벤트 리스너 명시적 제거(removeEventListener), WeakMap/WeakSet 사용, clearInterval/clearTimeout으로 타이머 해제, DOM 요소 참조 정리 등이 있습니다.

### 참고 자료
- [MDN: 메모리 문제 디버깅](https://developer.mozilla.org/ko/docs/Web/JavaScript/Memory_Management)
- [Chrome DevTools로 메모리 문제 해결하기](https://developers.google.com/web/tools/chrome-devtools/memory-problems)

### 메모리 누수 원인 및 해결법 도식화
```
┌──────────────────────────────────────────────┐
│      JavaScript 메모리 누수 주요 원인         │
└──────────────────────┬───────────────────────┘
                       │
       ┌───────────────┼───────────────┐
       │               │               │
       ▼               ▼               ▼
┌─────────────┐  ┌──────────────┐ ┌────────────┐
│ 전역 변수   │  │ 이벤트 리스너 │ │ 클로저     │
└──────┬──────┘  └───────┬──────┘ └─────┬──────┘
       │                 │              │
       ▼                 ▼              ▼
┌─────────────┐  ┌──────────────┐ ┌────────────┐
│ 해결 방법:  │  │ 해결 방법:   │ │ 해결 방법: │
│ - 변수 스코프│  │ - 컴포넌트   │ │ - 필요한   │
│   제한      │  │   언마운트 시 │ │   참조만   │
│ - 즉시 실행 │  │   리스너 제거 │ │   유지     │
│   함수 표현식│  │ - WeakMap    │ │ - 큰 객체  │
│ - 모듈 사용 │  │   사용       │ │   참조 해제 │
└─────────────┘  └──────────────┘ └────────────┘
       │                 │              │
       └─────────────────┼──────────────┘
                         │
                         ▼
┌──────────────────────────────────────────────┐
│               추가 원인                       │
└──────────────────────┬───────────────────────┘
                       │
       ┌───────────────┴───────────────┐
       │                               │
       ▼                               ▼
┌─────────────────────┐      ┌──────────────────┐
│ 타이머              │      │ DOM 요소 참조    │
│ (setInterval,       │      │                  │
│  setTimeout)        │      │                  │
└─────────┬───────────┘      └──────────┬───────┘
          │                             │
          ▼                             ▼
┌─────────────────────┐      ┌──────────────────┐
│ 해결 방법:          │      │ 해결 방법:       │
│ - clearInterval     │      │ - DOM 삭제 시    │
│ - clearTimeout      │      │   변수도 null로  │
│ - 컴포넌트 언마운트 │      │   설정          │
│   시 타이머 해제    │      │ - WeakMap 사용   │
└─────────────────────┘      └──────────────────┘
```

## 꼬리 질문 3
WeakMap과 Map의 차이점은 무엇인가요?

### 답변
WeakMap은 키로 객체만 사용할 수 있고, 키에 대한 약한 참조를 유지합니다. 키 객체가 다른 참조를 갖지 않으면 가비지 컬렉션의 대상이 되며, WeakMap에서도 자동으로 제거됩니다. 반면 Map은 모든 타입의 키를 허용하고, 키에 대한 강한 참조를 유지하여 가비지 컬렉션을 방해합니다. 또한 WeakMap은 keys(), values(), entries() 메서드와 size 속성이 없어 저장된 항목을 열거할 수 없습니다.

### 참고 자료
- [MDN: WeakMap](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/WeakMap)
- [MDN: Map](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Map)
- [JavaScript.info: WeakMap과 WeakSet](https://ko.javascript.info/weakmap-weakset)

### Map과 WeakMap 비교 도식화
```
┌──────────────────────────────────────────────┐
│            Map vs WeakMap                    │
└──────────────────────┬───────────────────────┘
                       │
       ┌───────────────┴───────────────┐
       │                               │
       ▼                               ▼
┌─────────────────────┐      ┌──────────────────┐
│        Map          │      │      WeakMap     │
└─────────┬───────────┘      └──────────┬───────┘
          │                             │
          ▼                             ▼
┌─────────────────────┐      ┌──────────────────┐
│ 특징:              │      │ 특징:            │
│ - 모든 타입의 키   │      │ - 객체만 키로 사용 │
│ - 키에 대한 강한   │      │ - 키에 대한 약한  │
│   참조 유지        │      │   참조 유지      │
│ - 전체 항목 열거   │      │ - 항목 열거 불가  │
│   가능             │      │ (keys, values,   │
│ - 키-값 개수 확인  │      │  entries 없음)   │
│   가능 (size)      │      │ - size 속성 없음  │
└─────────────────────┘      └──────────────────┘
          │                             │
          ▼                             ▼
┌─────────────────────┐      ┌──────────────────┐
│ 메모리 관리:        │      │ 메모리 관리:      │
│ 키 객체는 Map이     │      │ 키 객체가 다른    │
│ 참조하는 한 가비지  │      │ 곳에서 참조되지   │
│ 컬렉션 대상이 되지  │      │ 않으면 가비지     │
│ 않음                │      │ 컬렉션 대상이 됨  │
└─────────────────────┘      └──────────────────┘
          │                             │
          ▼                             ▼
┌─────────────────────┐      ┌──────────────────┐
│ 사용 사례:          │      │ 사용 사례:        │
│ - 데이터 캐싱       │      │ - 객체 관련 메타  │
│ - 순회 필요한 자료  │      │   데이터 저장     │
│ - 키-값 쌍 관리     │      │ - 메모리 누수     │
│                     │      │   방지 필요 시    │
└─────────────────────┘      └──────────────────┘
``` 
