# HTTP 버전 차이점

## 질문
컴퓨터 네트워크에서 HTTP/1.1, HTTP/2, HTTP/3의 차이점에 대해 설명해주세요.

## 답변
HTTP/1.1은 텍스트 기반 프로토콜로 연결당 하나의 요청만 처리하는 단점이 있습니다. HTTP/2는 바이너리 프로토콜로 멀티플렉싱, 헤더 압축, 서버 푸시 기능을 도입했습니다. HTTP/3는 TCP 대신 QUIC(UDP 기반) 프로토콜을 사용하여 연결 설정 지연을 줄이고 패킷 손실 시 단일 스트림만 영향받는 장점이 있습니다.

### 참고 자료
- [MDN: HTTP 개요](https://developer.mozilla.org/ko/docs/Web/HTTP/Overview)
- [HTTP/2 소개](https://web.dev/articles/performance-http2)
- [HTTP/3 소개](https://blog.cloudflare.com/ko-kr/http3-the-past-present-and-future-ko-kr/)

### HTTP 버전별 특징 도식화
```
┌──────────────────────────────────────────┐
│           HTTP 버전별 특징                │
└──────────────────────┬───────────────────┘
                       │
   ┌───────────────────┼───────────────────┐
   │                   │                   │
   ▼                   ▼                   ▼
┌─────────────┐   ┌─────────────┐   ┌─────────────┐
│  HTTP/1.1   │   │   HTTP/2    │   │   HTTP/3    │
└──────┬──────┘   └──────┬──────┘   └──────┬──────┘
       │                 │                 │
       ▼                 ▼                 ▼
┌─────────────┐   ┌─────────────┐   ┌─────────────┐
│- 텍스트 기반 │   │- 바이너리   │   │- QUIC 기반  │
│- 요청당 연결 │   │- 멀티플렉싱 │   │ (UDP)      │
│- Head of    │   │- 헤더 압축  │   │- 0-RTT 연결 │
│  Line 블로킹 │   │- 서버 푸시  │   │- 향상된     │
│- 기본 기능   │   │- 스트림 우선│   │  멀티플렉싱 │
│  (Keep-Alive)│   │  순위 지정  │   │- 패킷 손실  │
│              │   │             │   │  독립성    │
└─────────────┘   └─────────────┘   └─────────────┘
```

## 꼬리 질문 1
HTTP/2의 서버 푸시(Server Push) 기능과 활용 사례는 무엇인가요?

### 답변
서버 푸시는 클라이언트가 요청하기 전에 서버가 필요한 리소스를 미리 보내는 기능입니다. HTML 페이지와 함께 CSS, JavaScript, 이미지 등을 푸시하여 클라이언트의 추가 요청 없이 리소스를 제공할 수 있습니다. 활용 사례로는 초기 페이지 로드 시 필수 리소스 푸시, 특정 페이지 네비게이션 시 예상 리소스 푸시 등이 있습니다. 그러나 캐시 상태를 알 수 없어 불필요한 푸시가 발생할 수 있다는 단점이 있습니다.

### 참고 자료
- [HTTP/2 서버 푸시](https://web.dev/articles/service-worker-caching-and-http-caching)
- [MDN: HTTP/2 푸시](https://developer.mozilla.org/ko/docs/Web/HTTP/Headers/Link)

### 서버 푸시 동작 방식 도식화
```
┌───────────────────────────────────────────────────┐
│           HTTP/1.1 요청 처리 방식                  │
└───────────────────────┬───────────────────────────┘
                        │
                        ▼
┌──────────────┐    ┌───────────┐    ┌──────────────┐
│ 클라이언트   │───▶│HTML 요청  │───▶│    서버      │
└──────────────┘    └───────────┘    └──────┬───────┘
        ▲                                   │
        │                                   │
        │                                   ▼
        │                             ┌───────────┐
        └─────────────────────────────│HTML 응답  │
                                      └───────────┘
        ▲                                   │
        │                                   │
        │                                   ▼
┌──────────────┐    ┌───────────┐    ┌──────────────┐
│ CSS, JS,     │◀───│ 추가 요청 │◀───│ HTML 파싱    │
│ 이미지 응답  │    │           │    │              │
└──────────────┘    └───────────┘    └──────────────┘


┌───────────────────────────────────────────────────┐
│            HTTP/2 서버 푸시 방식                  │
└───────────────────────┬───────────────────────────┘
                        │
                        ▼
┌──────────────┐    ┌───────────┐    ┌──────────────┐
│ 클라이언트   │───▶│HTML 요청  │───▶│    서버      │
└──────────────┘    └───────────┘    └──────┬───────┘
        ▲                                   │
        │                                   │
        │                                   ▼
        │                             ┌───────────┐
        │                             │HTML 응답  │
        │                             └─────┬─────┘
        │                                   │
        │     ┌─────────────────────────────┘
        │     │
        │     ▼
┌──────────────┐                       ┌──────────────┐
│ HTML + CSS   │◀──────────────────────│ 서버 푸시    │
│ + JS + 이미지│                       │ (예상 리소스) │
└──────────────┘                       └──────────────┘
```

## 꼬리 질문 2
HTTPS 동작 원리와 SSL/TLS 핸드셰이크 과정을 설명해주세요.

### 답변
HTTPS는 HTTP 통신을 SSL/TLS로 암호화하는 프로토콜입니다. 핸드셰이크 과정은 다음과 같습니다: 1) 클라이언트가 서버에 연결 요청과 지원 암호화 방식 전송, 2) 서버가 인증서와 선택한 암호화 방식 응답, 3) 클라이언트가 인증서 검증 후 대칭키 생성에 사용할 임시 키 전송, 4) 서버와 클라이언트가 동일한 대칭키 계산, 5) 이후 통신은 합의된 대칭키로 암호화. 이 과정을 통해 안전한 통신 채널이 구축됩니다.

### 참고 자료
- [MDN: HTTPS](https://developer.mozilla.org/ko/docs/Web/HTTP/HTTPS)
- [SSL/TLS 핸드셰이크 설명](https://www.cloudflare.com/ko-kr/learning/ssl/what-happens-in-a-tls-handshake/)

### SSL/TLS 핸드셰이크 도식화
```
┌──────────────┐                       ┌──────────────┐
│  클라이언트  │                       │     서버     │
└──────┬───────┘                       └──────┬───────┘
       │                                      │
       │  ClientHello                         │
       │  (지원하는 TLS 버전, 암호화 스위트)   │
       │─────────────────────────────────────▶│
       │                                      │
       │  ServerHello                         │
       │  (선택된 TLS 버전, 암호화 스위트)     │
       │  서버 인증서                         │
       │◀─────────────────────────────────────│
       │                                      │
       │  인증서 검증                         │
       │  사전 마스터 비밀 생성               │
       │  공개키로 암호화                     │
       │                                      │
       │  클라이언트 키 교환                  │
       │  (암호화된 사전 마스터 비밀)         │
       │─────────────────────────────────────▶│
       │                                      │
       │                 사전 마스터 비밀 복호화│
       │                                      │
       │  Finished                           │
       │  (마스터 비밀로 암호화된 핸드셰이크 메시지│
       │   해시)                             │
       │─────────────────────────────────────▶│
       │                                      │
       │  Finished                           │
       │  (마스터 비밀로 암호화된 핸드셰이크 메시지│
       │   해시)                             │
       │◀─────────────────────────────────────│
       │                                      │
       │  안전한 통신 시작                    │
       │  (대칭키로 암호화된 데이터)          │
       │◀────────────────────────────────────▶│
       │                                      │
```

## 꼬리 질문 3
REST API와 GraphQL의 차이점 및 각각의 장단점은 무엇인가요?

### 답변
REST API는 URI로 자원을 표현하고 HTTP 메서드로 자원에 대한 행위를 정의하는 방식으로, 구조가 명확하고 캐싱이 용이하지만 오버페칭/언더페칭 문제가 있습니다. GraphQL은 단일 엔드포인트에서 필요한 데이터만 정확히 요청할 수 있는 쿼리 언어로, 오버페칭 문제를 해결하고 강력한 타입 시스템을 제공하지만, 캐싱 구현이 복잡하고 파일 업로드 등 일부 기능 구현이 REST보다 어렵습니다. REST는 간단한 API에, GraphQL은 복잡한 데이터 요구사항이 있는 애플리케이션에 적합합니다.

### 참고 자료
- [GraphQL 공식 문서](https://graphql.org/learn/)
- [REST API 디자인 가이드](https://restfulapi.net/)
- [REST vs GraphQL 비교](https://www.apollographql.com/blog/graphql/basics/graphql-vs-rest/)

### REST API vs GraphQL 도식화
```
┌───────────────────────────────────────────────┐
│                 REST API                      │
└───────────────────────┬───────────────────────┘
                        │
                        ▼
┌───────────────────────────────────────────────┐
│ 다중 엔드포인트                                │
│                                               │
│ GET    /users/123      ┌─────────────────┐    │
│ GET    /users/123/posts│ 서버 응답 데이터 │    │
│ PUT    /posts/456      │ (전체 리소스)    │    │
│ DELETE /comments/789   └─────────────────┘    │
└───────────────────────────────────────────────┘
            장점                   단점
┌───────────────────┐   ┌───────────────────────┐
│ - 구조적으로 명확  │   │ - 오버페칭(과잉 조회) │
│ - 캐싱 용이       │   │ - 언더페칭(과소 조회) │
│ - 상태 코드 표준화 │   │ - 여러 API 호출 필요 │
│ - 널리 채택됨     │   │ - 버전 관리 복잡     │
└───────────────────┘   └───────────────────────┘

┌───────────────────────────────────────────────┐
│                 GraphQL                       │
└───────────────────────┬───────────────────────┘
                        │
                        ▼
┌───────────────────────────────────────────────┐
│ 단일 엔드포인트                                │
│                                               │
│ POST /graphql         ┌─────────────────┐    │
│ query {               │ 서버 응답 데이터 │    │
│   user(id: "123") {   │ (요청한 필드만)  │    │
│     name              └─────────────────┘    │
│     posts {                                  │
│       title                                  │
│     }                                        │
│   }                                          │
│ }                                            │
└───────────────────────────────────────────────┘
            장점                   단점
┌───────────────────┐   ┌───────────────────────┐
│ - 정확한 데이터   │   │ - 복잡한 쿼리 가능    │
│   요청 가능       │   │ - 캐싱 구현 복잡     │
│ - 오버페칭 방지   │   │ - 파일 업로드 복잡   │
│ - 타입 시스템     │   │ - 러닝 커브 존재     │
│ - 단일 요청으로   │   │ - 에러 처리 방식 다름│
│   데이터 조회     │   │                      │
└───────────────────┘   └───────────────────────┘
``` 
