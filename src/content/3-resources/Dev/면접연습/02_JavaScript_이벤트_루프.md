# JavaScript의 이벤트 루프

## 질문
JavaScript의 이벤트 루프에 대해 설명해주세요.

## 답변
JavaScript는 싱글 스레드 언어지만 이벤트 루프를 통해 비동기 작업을 처리합니다. 이벤트 루프는 콜 스택이 비어있을 때 태스크 큐에서 콜백을 꺼내 실행합니다. 이벤트 루프는 콜 스택, Web API, 콜백 큐(태스크 큐와 마이크로태스크 큐)로 구성되어 있습니다.

### 참고 자료
- [MDN: 이벤트 루프](https://developer.mozilla.org/ko/docs/Web/JavaScript/EventLoop)
- [Jake Archibald: Tasks, microtasks, queues and schedules](https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/)

### 이벤트 루프 도식화
```
┌─────────────┐     ┌───────────┐
│  Call Stack  │     │  Web APIs │
└─────┬───────┘     └─────┬─────┘
      │                   │
      │                   ▼
      │           ┌───────────────┐
      │           │ Callback Queue│
      │           └───────┬───────┘
      │                   │
      └─────────┬─────────┘
                │
                ▼
        ┌───────────────┐
        │ Event Loop    │
        └───────────────┘
```

## 꼬리 질문 1
마이크로태스크와 매크로태스크의 차이점은 무엇인가요?

### 답변
마이크로태스크는 Promise.then/catch/finally, queueMicrotask, MutationObserver 등에서 생성되며, 매크로태스크는 setTimeout, setInterval, I/O, UI 렌더링 등에서 생성됩니다. 마이크로태스크 큐는 매크로태스크보다 우선순위가 높아, 현재 매크로태스크 완료 후 다음 매크로태스크 실행 전에 모든 마이크로태스크가 처리됩니다.

### 참고 자료
- [JavaScript Visualized: Event Loop](https://dev.to/lydiahallie/javascript-visualized-event-loop-3dif)
- [MDN: 동시성 모델과 이벤트 루프](https://developer.mozilla.org/ko/docs/Web/JavaScript/EventLoop)

### 실행 순서 도식화
```
┌─────────────────────────────────────┐
│           이벤트 루프 실행 순서       │
└───────────────────┬─────────────────┘
                    │
                    ▼
          ┌────────────────────┐
          │ 매크로태스크 실행    │
          └──────────┬─────────┘
                     │
                     ▼
          ┌────────────────────┐
          │ 모든 마이크로태스크  │◄─────┐
          │ 큐 실행            │      │
          └──────────┬─────────┘      │
                     │                │
                     ▼                │
          ┌────────────────────┐      │
          │ 마이크로태스크 중   │      │
          │ 새 마이크로태스크가 │──────┘
          │ 생성되었는가?      │
          └──────────┬─────────┘
                     │ 아니오
                     ▼
          ┌────────────────────┐
          │ 렌더링 업데이트     │
          │ (필요한 경우)      │
          └──────────┬─────────┘
                     │
                     ▼
          ┌────────────────────┐
          │ 다음 매크로태스크   │
          │ 실행               │
          └────────────────────┘
```

## 꼬리 질문 2
비동기 처리 방식의 발전 과정(콜백, Promise, async/await)에 대해 설명해주세요.

### 답변
초기에는 콜백 패턴을 사용했으나 중첩이 많아지면 콜백 지옥 문제가 발생했습니다. ES6에서 Promise가 도입되어 체이닝 방식으로 가독성을 높였고, ES8에서는 async/await가 도입되어 비동기 코드를 동기 코드처럼 작성할 수 있게 되었습니다. async/await는 Promise를 기반으로 하지만 더 직관적인 문법을 제공합니다.

### 참고 자료
- [MDN: Promise 사용하기](https://developer.mozilla.org/ko/docs/Web/JavaScript/Guide/Using_promises)
- [MDN: Async/await](https://developer.mozilla.org/ko/docs/Learn/JavaScript/Asynchronous/Async_await)

### 발전 과정 도식화
```
┌───────────────────┐
│ 콜백 패턴 (초기)   │
└─────────┬─────────┘
          │
          ▼
┌───────────────────────────────────┐
│ 콜백 지옥                          │
│ getData(function(a){              │
│   getMoreData(a, function(b){     │
│     getEvenMoreData(b, function(c){│
│       ...                         │
│     });                          │
│   });                            │
│ });                              │
└─────────────────┬─────────────────┘
                  │
                  ▼
┌───────────────────────────────────┐
│ Promise (ES6)                     │
│ getData()                         │
│   .then(a => getMoreData(a))      │
│   .then(b => getEvenMoreData(b))  │
│   .then(c => ...)                 │
│   .catch(error => ...)            │
└─────────────────┬─────────────────┘
                  │
                  ▼
┌───────────────────────────────────┐
│ Async/Await (ES8)                 │
│ async function process() {        │
│   try {                           │
│     const a = await getData();    │
│     const b = await getMoreData(a);│
│     const c = await getEvenMoreData(b);│
│     ...                           │
│   } catch (error) {               │
│     ...                           │
│   }                               │
│ }                                 │
└───────────────────────────────────┘
```

## 꼬리 질문 3
JavaScript의 비동기 처리가 필요한 이유는 무엇인가요?

### 답변
JavaScript는 브라우저에서 싱글 스레드로 실행되므로, 시간이 오래 걸리는 작업(네트워크 요청, 파일 IO, 타이머 등)을 동기적으로 처리하면 UI가 멈추게 됩니다. 비동기 처리를 통해 이러한 작업들을 백그라운드에서 처리하며 메인 스레드 블로킹을 방지하여 사용자 경험을 향상시킬 수 있습니다.

### 참고 자료
- [MDN: 비동기 JavaScript 소개](https://developer.mozilla.org/ko/docs/Learn/JavaScript/Asynchronous/Introducing)
- [JavaScript.info: 이벤트 루프, 마이크로태스크, 매크로태스크](https://ko.javascript.info/event-loop)

### 비동기 처리의 필요성 도식화
```
┌───────────────────────────────────────────┐
│           동기적 처리의 문제점             │
└───────────────────┬───────────────────────┘
                    │
       ┌────────────┴─────────────┐
       │                          │
       ▼                          ▼
┌──────────────┐          ┌──────────────────┐
│ 메인 스레드   │──────────▶│ 시간이 오래      │
│ 블로킹        │          │ 걸리는 작업      │
└──────────────┘          └──────────────────┘
       │                          │
       ▼                          │
┌──────────────┐                  │
│ UI 응답성    │                  │
│ 저하         │◀─────────────────┘
└──────────────┘

┌───────────────────────────────────────────┐
│            비동기 처리의 장점              │
└───────────────────┬───────────────────────┘
                    │
      ┌─────────────┴─────────────┐
      │                           │
      ▼                           ▼
┌────────────┐             ┌─────────────────┐
│ 메인 스레드 │             │ 시간이 오래      │
│             │──────┐     │ 걸리는 작업      │
└────────────┘      │     └─────────────────┘
      │             │             │
      │             ▼             │
      │      ┌─────────────┐      │
      │      │ Web API/    │      │
      │      │ 백그라운드   │◀─────┘
      │      └──────┬──────┘
      │             │
      │             ▼
      │      ┌─────────────┐
      │      │ 콜백 큐에    │
      │      │ 추가         │
      │      └──────┬──────┘
      │             │
      ▼             ▼
┌────────────────────────┐
│ 이벤트 루프를 통한     │
│ 비동기 처리            │
└────────────────────────┘
``` 
