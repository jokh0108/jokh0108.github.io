# 웹 성능 최적화

## 질문
웹 성능 최적화 방법에 대해 설명해주세요.

## 답변
웹 성능 최적화는 리소스 최적화(이미지 압축, 코드 분할), 네트워크 최적화(CDN 활용, HTTP/2 사용), 렌더링 최적화(CSS/JS 최적화, 레이아웃 변경 최소화) 등으로 구분됩니다. 또한 캐싱 전략 수립, 레이지 로딩 구현, 서버 응답 시간 개선도 중요합니다. 성능 측정 도구(Lighthouse, WebPageTest)를 활용하여 문제점을 파악하고 개선해나가야 합니다.

### 참고 자료
- [웹 성능 최적화 가이드](https://web.dev/fast/)
- [MDN: 웹 성능](https://developer.mozilla.org/ko/docs/Web/Performance)
- [Google Lighthouse](https://developers.google.com/web/tools/lighthouse)

### 웹 성능 최적화 영역 도식화
```
┌───────────────────────────────────────┐
│          웹 성능 최적화 영역           │
└──────────────────┬────────────────────┘
                   │
       ┌───────────┼───────────┐
       │           │           │
       ▼           ▼           ▼
┌─────────────┐ ┌──────────┐ ┌────────────┐
│ 리소스 최적화│ │네트워크  │ │렌더링 최적화│
└──────┬──────┘ │최적화    │ └─────┬──────┘
       │        └────┬─────┘       │
       │             │             │
       ▼             ▼             ▼
┌─────────────┐ ┌──────────┐ ┌────────────┐
│ - 이미지 압축│ │- CDN 활용│ │- CSS 최적화│
│ - 코드 분할  │ │- HTTP/2  │ │- JS 최적화 │
│ - 트리 쉐이킹│ │- 압축    │ │- 레이아웃  │
│ - 번들 최적화│ │- 프리로딩│ │  변경 최소화│
└─────────────┘ └──────────┘ └────────────┘
```

## 꼬리 질문 1
Core Web Vitals의 주요 지표와 개선 방법은 무엇인가요?

### 답변
Core Web Vitals는 LCP(Largest Contentful Paint), FID(First Input Delay), CLS(Cumulative Layout Shift)로 구성됩니다. LCP는 이미지 최적화, 중요 리소스 프리로드, 서버 응답 시간 개선으로, FID는 JavaScript 실행 최적화, 코드 분할, 불필요한 서드파티 스크립트 제거로, CLS는 이미지와 광고 요소에 크기 속성 지정, 동적 콘텐츠 위치 예약으로 개선할 수 있습니다.

### 참고 자료
- [Core Web Vitals 공식 문서](https://web.dev/vitals/)
- [LCP 최적화 가이드](https://web.dev/optimize-lcp/)
- [FID 최적화 가이드](https://web.dev/optimize-fid/)
- [CLS 최적화 가이드](https://web.dev/optimize-cls/)

### Core Web Vitals 도식화
```
┌───────────────────────────────────────┐
│           Core Web Vitals              │
└───────────────────┬───────────────────┘
                    │
    ┌───────────────┼───────────────┐
    │               │               │
    ▼               ▼               ▼
┌─────────────┐ ┌─────────────┐ ┌─────────────┐
│     LCP     │ │     FID     │ │     CLS     │
│(로딩 성능)   │ │(상호작용 지연)│ │(시각적 안정성)│
└──────┬──────┘ └──────┬──────┘ └──────┬──────┘
       │               │               │
       ▼               ▼               ▼
┌─────────────┐ ┌─────────────┐ ┌─────────────┐
│ 좋음: ≤2.5초 │ │ 좋음: ≤100ms │ │ 좋음: ≤0.1  │
│ 개선필요:    │ │ 개선필요:    │ │ 개선필요:    │
│   ≤4초      │ │   ≤300ms    │ │   ≤0.25     │
│ 나쁨: >4초   │ │ 나쁨: >300ms │ │ 나쁨: >0.25  │
└─────────────┘ └─────────────┘ └─────────────┘
```

## 꼬리 질문 2
브라우저 캐싱 전략과 ServiceWorker를 활용한 오프라인 지원 방법은 무엇인가요?

### 답변
브라우저 캐싱은 Cache-Control, ETag, Expires 헤더로 제어합니다. ServiceWorker는 PWA의 핵심 기술로, 네트워크 요청을 가로채 캐시 저장소에서 응답을 제공할 수 있습니다. CacheStorage API와 함께 사용하여 정적 자산을 캐싱하고 오프라인 지원을 구현합니다. 다양한 캐싱 전략(Cache First, Network First, Stale-While-Revalidate 등)을 상황에 맞게 적용해야 합니다.

### 참고 자료
- [MDN: ServiceWorker API](https://developer.mozilla.org/ko/docs/Web/API/Service_Worker_API)
- [Google Web Fundamentals: ServiceWorker 소개](https://developers.google.com/web/fundamentals/primers/service-workers)
- [Workbox: 캐싱 전략](https://developers.google.com/web/tools/workbox/modules/workbox-strategies)

### 캐싱 전략 도식화
```
┌───────────────────────────────────────┐
│           브라우저 캐싱 전략            │
└───────────────────┬───────────────────┘
                    │
    ┌───────────────┼───────────────┐
    │               │               │
    ▼               ▼               ▼
┌─────────────┐ ┌─────────────┐ ┌─────────────┐
│ Cache First  │ │Network First│ │Stale-While- │
│              │ │             │ │Revalidate   │
└──────┬──────┘ └──────┬──────┘ └──────┬──────┘
       │               │               │
       ▼               ▼               ▼
┌─────────────┐ ┌─────────────┐ ┌─────────────┐
│1. 캐시 확인  │ │1. 네트워크  │ │1. 캐시 확인  │
│2. 캐시 있음: │ │   요청      │ │2. 캐시 있음: │
│   캐시 응답  │ │2. 성공:     │ │   캐시 응답  │
│3. 캐시 없음: │ │   응답 캐싱 │ │3. 동시에    │
│   네트워크   │ │3. 실패:     │ │   네트워크   │
│   요청 후    │ │   캐시 확인 │ │   요청      │
│   캐싱       │ │             │ │4. 다음 요청 시│
└─────────────┘ └─────────────┘ │   새 응답 사용│
                                └─────────────┘

┌───────────────────────────────────────┐
│     ServiceWorker 등록 및 활성화       │
└───────────────────┬───────────────────┘
                    │
                    ▼
┌───────────────────────────────────────┐
│ // ServiceWorker 등록                  │
│ if ('serviceWorker' in navigator) {    │
│   navigator.serviceWorker.register(    │
│     '/sw.js'                          │
│   );                                  │
│ }                                     │
└───────────────────┬───────────────────┘
                    │
                    ▼
┌───────────────────────────────────────┐
│ // ServiceWorker 설치 이벤트           │
│ self.addEventListener('install', (e) => {│
│   e.waitUntil(                        │
│     caches.open('v1').then((cache) => {│
│       return cache.addAll([           │
│         '/index.html',                │
│         '/styles.css',                │
│         '/app.js'                     │
│       ]);                             │
│     })                                │
│   );                                  │
│ });                                    │
└───────────────────────────────────────┘
```

## 꼬리 질문 3
코드 분할(Code Splitting)과 트리 쉐이킹(Tree Shaking)의 차이점과 구현 방법은 무엇인가요?

### 답변
코드 분할은 애플리케이션 코드를 여러 청크로 나눠 필요할 때만 로드하는 기법으로, 동적 import(), React.lazy()와 같은 방법으로 구현합니다. 트리 쉐이킹은 번들에서 사용하지 않는 코드를 제거하는 기법으로, ES 모듈 시스템과 Webpack, Rollup 같은 번들러의 최적화 기능을 통해 구현합니다. 코드 분할은 초기 로드 시간을 줄이고, 트리 쉐이킹은 번들 크기 자체를 줄입니다.

### 참고 자료
- [Webpack: 코드 분할](https://webpack.js.org/guides/code-splitting/)
- [Webpack: 트리 쉐이킹](https://webpack.js.org/guides/tree-shaking/)
- [React: 코드 분할](https://ko.reactjs.org/docs/code-splitting.html)

### 코드 분할 및 트리 쉐이킹 도식화
```
┌───────────────────────────────────────┐
│      코드 분할 vs 트리 쉐이킹           │
└───────────────────┬───────────────────┘
                    │
           ┌────────┴────────┐
           │                 │
           ▼                 ▼
┌─────────────────────┐ ┌─────────────────────┐
│    코드 분할         │ │     트리 쉐이킹      │
└─────────┬───────────┘ └─────────┬───────────┘
          │                       │
          ▼                       ▼
┌─────────────────────┐ ┌─────────────────────┐
│ 목적: 큰 번들을      │ │ 목적: 사용하지 않는  │
│ 여러 작은 번들로 분리 │ │ 코드를 제거         │
└─────────┬───────────┘ └─────────┬───────────┘
          │                       │
          ▼                       ▼
┌─────────────────────┐ ┌─────────────────────┐
│ 구현 방법:          │ │ 구현 방법:          │
│ - 동적 import()     │ │ - ES 모듈 사용      │
│ - React.lazy()      │ │ - sideEffects 설정  │
│ - 라우트 기반 분할   │ │ - 최적화 모드 활성화 │
└─────────────────────┘ └─────────────────────┘
``` 
